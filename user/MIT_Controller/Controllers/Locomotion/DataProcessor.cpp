#include <Utilities/Timer.h>
//#include <rt/rt_interface_lcm.h>

#include <cmath>
#include <iostream>
#include <fstream>
#include <json/writer.h>
#include <json/value.h>
#include <json/reader.h>
#include <cppTypes.h>

#include <boost/format.hpp>
#include "Controllers/LegController.h"
#include "Dynamics/MiniCheetah.h"
#include "Dynamics/DynamicsSimulator.h"
#include "Dynamics/FloatingBaseModel.h"
#include "Dynamics/Quadruped.h"
#include "Dynamics/spatial.h"
#include "Utilities/utilities.h"
#include "DataProcessor.hpp"
#include <libInterpolate/Interpolate.hpp>
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"

// This class is to convert the json file generated by TOWR to a .dat file 
// and compute q, qd and tau required by the PD controller. 

template <typename Iterable>
Json::Value iterable2json(Iterable const& cont);
Eigen::VectorXd convertJson2Arr(Eigen::Vector4d arr, Json::Value &j);
Vec3<double> convertJson2Vec(Vec3<double> vec, Json::Value &j);
Eigen::Matrix3d convertJson2Mat(Eigen::Matrix3d mat, Json::Value &js);
Eigen::VectorXd convertJson2Xd(Eigen::VectorXd jointPos, Json::Value &js);
SVec<double> convertJson2SVec(SVec<double> arr, Json::Value &j1, Json::Value &j2);

DataProcessor::DataProcessor()  {
  std::ifstream file_in("/home/chris/Desktop/latest/Cheetah-Software/user/MIT_Controller/ros_output.json", std::ifstream::binary);
  if (!file_in.is_open()){
       std::cout << "Error opening file"<< std::endl;
       exit (1);
  }
  Json::Reader reader; 
  bool parseSuccessful = reader.parse(file_in, opt);
  if (!parseSuccessful) {
    std::cout
     << "ERROR DURING PARSING JSON FILE.";
  }

  result = new Eigen::MatrixXd[1001];
  for (int j = 0; j < 1001; j++) {
    result[j] = Eigen::VectorXd::Zero(60);
  }
  (*result).resize(1001, 60);

  int ptr = 0; 
  using namespace std; 
  time = 0. + 1e-6;

  //  Time Interpolation
  // _1D::LinearInterpolator<double> interp;

  // using namespace rapidjson; 
  // Json::FastWriter fastWriter;
  // std::string j = fastWriter.write(opt);
  // Document doc; 
  // const char* c = j.c_str();
  // doc.Parse(c);
  // const rapidjson::Value& v = doc["data"]; 

  Eigen::VectorXd timeVec; 
  timeVec.resize(1001);
  timeVec[0] = time; 
  for (int t_index = 1; t_index<1001;t_index++) {
    timeVec[t_index] = timeVec[t_index - 1] + 0.002; 
  }



  vector<vector<double>> linearVel_interp, linearPos_interp, linearAcc_interp, angVel_interp, angPos_interp, footForces_interp, jointTorques_interp, jointPos_interp, jointVel_interp;
  Vec3<double> linearVel, linearPos, angPos, angVel, FootForces;
  Vec12<double> jointPos, jointVel, newjointTorques;
  SVec<double> linearAngAcc(6);
  linearPos_interp.resize(1000);
  linearPos_interp.resize(1000);
  linearAcc_interp.resize(1000);
  angVel_interp.resize(1000);
  angPos_interp.resize(1000);
  footForces_interp.resize(1000);
  jointTorques_interp.resize(1000);
  jointPos_interp.resize(1000);
  jointVel_interp.resize(1000);


  Vec3<double> tmplinearVel, tmplinearPos, tmpangPos, tmpangVel, tmpfootForces;
  Vec12<double> tmpjointPos, tmpjointVel, tmpjointTorques; 
  SVec<double> tmplinearAngAcc(6); 


  while (time < 2) {

    Vec3<double> pos, omegaBody, vBody; 
    Eigen::Matrix3d mat; 
    Eigen::VectorXd jointAng;
    jointAng.resize(12);
    DVec<double> q(12);
    DVec<double> dq(12);
    DVec<double> tauref(12);

  cheetahModel = buildMiniCheetah<double>().buildModel(); 
  
  // Do something that has the same effect as time interpolation
  if (abs(timeVec[ptr] -  time) < 0.000001) {
    t = timeVec[ptr]; 
  } else {
    for (int start = 0; start < timeVec.size(); start++) {
      if (abs(timeVec[start] - time) <= 0.00002) {
        t = timeVec[start];
        break;
      }
    }
  }

  // std::cout << "t:   " << t << " " << std::endl;
  // std::cout << "time:   " << time << " " << std::endl;
  // std::cout << "timeVec[ptr]" << timeVec[ptr] << std::endl;
  // std::cout << "ptr:  " << ptr << std::endl;

  // set state
    x.bodyOrientation = rotationMatrixToQuaternion(convertJson2Mat(mat, opt["data"][to_string(t)]["Quat"])); // Quat 
    x.bodyPosition    = convertJson2Vec(pos, opt["data"][to_string(t)]["Base linear position"]);
    x.bodyVelocity.head(3) = convertJson2Vec(omegaBody, opt["data"][to_string(t)]["Base euler velocity"]); //omegaBody
    x.bodyVelocity.tail(3) = convertJson2Vec(vBody, opt["data"][to_string(t)]["Base linear velocity"]);  //vBody
    x.q = convertJson2Xd(jointAng, opt["data"][to_string(t)]["Joint position"]);
    x.qd = ComputeJointVelocities(t);
    cheetahModel.setState(x);


    // Construct state derivative
    DVec<double> qdd(12);
    qdd.setZero();
    
    SVec<double> vbd =  convertJson2SVec(vbd,  opt["data"][to_string(t)]["Base linear acceleration"], opt["data"][to_string(t)]["Base angular acceleration"]);
    FBModelStateDerivative<double> dx;
    dx.dBodyVelocity = vbd;
    dx.qdd = qdd;
    cheetahModel.setDState(dx);
    qdd(0) = (cheetahModel.getLinearAcceleration(0))(0);
    qdd(1) = (cheetahModel.getLinearAcceleration(0))(1);
    qdd(2) = (cheetahModel.getLinearAcceleration(0))(2);
    qdd(3) = (cheetahModel.getLinearAcceleration(1))(0);
    qdd(4) = (cheetahModel.getLinearAcceleration(1))(1);
    qdd(5) = (cheetahModel.getLinearAcceleration(1))(2);
    qdd(6) = (cheetahModel.getLinearAcceleration(2))(0);
    qdd(7) = (cheetahModel.getLinearAcceleration(2))(1);
    qdd(8) = (cheetahModel.getLinearAcceleration(2))(2);
    qdd(9) = (cheetahModel.getLinearAcceleration(3))(0);
    qdd(10) = (cheetahModel.getLinearAcceleration(3))(1);
    qdd(11) = (cheetahModel.getLinearAcceleration(3))(2);

    // Compute ID two different ways
    genForce = cheetahModel.inverseDynamics(dx);
    jointTorques = genForce.tail(12);


    // LOAD FOOT FORCE 
    Eigen::Vector3d foot0, foot1, foot2, foot3; 

    Eigen::Vector3d f1, f2, f3, f4; 
    f1 = convertJson2Vec(foot0, opt["data"][to_string(t)]["Contact forces"]["0"]); 
    f2 = convertJson2Vec(foot1, opt["data"][to_string(t)]["Contact forces"]["1"]); 
    f3 = convertJson2Vec(foot2, opt["data"][to_string(t)]["Contact forces"]["2"]); 
    f4 = convertJson2Vec(foot3, opt["data"][to_string(t)]["Contact forces"]["3"]); 
    for (int in = 0; in < 3; in++) {
      footForces[in] = f1[in];
      footForces[in + 3] = f2[in];
      footForces[in + 6] = f3[in];
      footForces[in + 9] = f4[in];
    }

  // for (int timeInd = 0; timeInd < timeVec.size(); timeInd++) {
  //   linearVel = convertJson2Vec(tmplinearVel, opt["data"][to_string(timeVec[timeInd])]["Base linear velocity"]);
  //   linearPos = convertJson2Vec(tmplinearPos, opt["data"][to_string(timeVec[timeInd])]["Base linear position"]);
  //   linearAngAcc = convertJson2SVec(tmplinearAngAcc,  opt["data"][to_string(timeVec[timeInd])]["Base linear acceleration"], opt["data"][to_string(timeVec[timeInd])]["Base angular acceleration"]);
  //   angPos = convertJson2Vec(tmpangPos, opt["data"][to_string(timeVec[timeInd])]["Base angular position"]);
  //   angVel = convertJson2Vec(tmpangVel, opt["data"][to_string(timeVec[timeInd])]["Base angular velocity"]);
  //   jointPos = convertJson2Xd(tmpjointPos, opt["data"][to_string(timeVec[timeInd])]["Joint Position"]);
  //   jointVel = ComputeJointVelocities(timeVec[timeInd]);

  //   // Convert Eigen::Vector to std::vector; 
  //   std::vector<double> linearVelVec(linearVel.data(), linearVel.data() + linearVel.size());
  //   std::vector<double> linearPosVec(linearPos.data(), linearPos.data() + linearPos.size());
  //   std::vector<double> linearAccVec(linearAngAcc.data(), linearAngAcc.data() + linearAngAcc.size());
  //   std::vector<double> angVelVec(angVel.data(), angVel.data() + angVel.size());
  //   std::vector<double> angPosVec(angPos.data(), angPos.data() + angPos.size());
  //   std::vector<double> jointPosVec(jointPos.data(), jointPos.data() + jointPos.size());
  //   std::vector<double> jointVelVec(jointVel.data(), jointVel.data() + jointVel.size());

  //   linearPos_interp.push_back(linearPosVec);
  //   linearVel_interp.push_back(linearVelVec);
  //   linearAcc_interp.push_back(linearAccVec);
  //   angVel_interp.push_back(angVelVec);
  //   angPos_interp.push_back(angPosVec);
  //   jointPos_interp.push_back(jointPosVec);
  //   jointVel_interp.push_back(jointVelVec);
  // }



  // Contatenation 
  // for (int i = 1; i < linearPos_interp.size(); i++) {
  //   linearPos_interp[0].insert(linearPos_interp[i].end(), linearPos_interp[i+1].begin(), linearPos_interp[i+1].end());
  // }
  

  // interp.setData(timeVec, linearPos_interp);

  // Construct state derivative
  // DVec<double> qddInterp(12);
  
  // qddInterp.setZero();
  
  // FBModelStateDerivative<double> dx;
  // dx.dBodyVelocity = linearAngAcc;
  // dx.qdd = qddInterp;
  // cheetahModel.setDState(dx);
  // qdd(0) = (cheetahModel.getLinearAcceleration(0))(0);
  // qdd(1) = (cheetahModel.getLinearAcceleration(0))(1);
  // qdd(2) = (cheetahModel.getLinearAcceleration(0))(2);
  // qdd(3) = (cheetahModel.getLinearAcceleration(1))(0);
  // qdd(4) = (cheetahModel.getLinearAcceleration(1))(1);
  // qdd(5) = (cheetahModel.getLinearAcceleration(1))(2);
  // qdd(6) = (cheetahModel.getLinearAcceleration(2))(0);
  // qdd(7) = (cheetahModel.getLinearAcceleration(2))(1);
  // qdd(8) = (cheetahModel.getLinearAcceleration(2))(2);
  // qdd(9) = (cheetahModel.getLinearAcceleration(3))(0);
  // qdd(10) = (cheetahModel.getLinearAcceleration(3))(1);
  // qdd(11) = (cheetahModel.getLinearAcceleration(3))(2);

  // // Compute ID two different ways
  // genForceInterp = cheetahModel.inverseDynamics(dx);
  // jointTorques = genForce.tail(12);

  std::cout << "INPUT DATA        " << "time: " << time << std::endl;
  std::cout << x.bodyPosition[0] << " " << x.bodyPosition[1] << " " << x.bodyPosition[2] <<  " " << x.bodyOrientation[0] << " " << x.bodyOrientation[1] << " " << x.bodyOrientation[2] <<  " ";
  std::cout << (x.q)[0] << " " << (x.q)[1] << " " << (x.q)[2] << " " << (x.q)[3] << " " << (x.q)[4] << " " << (x.q)[5] << " " << (x.q)[6] <<  " " << (x.q)[7] <<  " " << (x.q)[8] <<  " " << (x.q)[9] << " " << (x.q)[10] << " " << (x.q)[11] << " ";
  std::cout << x.bodyVelocity[0] <<  " " << x.bodyVelocity[1] << " " << x.bodyVelocity[2] <<  " " <<  x.bodyVelocity[3]<< " " << x.bodyVelocity[4] << " " <<  x.bodyVelocity[5] << " ";
  std::cout << (x.qd)[0] << " " << (x.qd)[1] << " " << (x.qd)[2] << " " << (x.qd)[3] << " " << (x.qd)[4] << " " << (x.qd)[5] << " " << (x.qd)[6] << " " << (x.qd)[7] << " " << (x.qd)[8] << " " << (x.qd)[9] << " " << (x.qd)[10] << " " << (x.qd)[11] << " ";
  std::cout << jointTorques[0] << " " << jointTorques[1] << " " << jointTorques[2] << " " << jointTorques[3] << " " << jointTorques[4] << " " << jointTorques[5] << " " << jointTorques[6] << " " << jointTorques[7] << " ";
  std::cout << jointTorques[8] << " " << jointTorques[9] << " " << jointTorques[10] << " " << jointTorques[11] << " ";
  std::cout << footForces[0] << " " << footForces[1] << " " << footForces[2] << " " << footForces[3] << " " << footForces[4] << " " << footForces[5] << " " << footForces[6] << " " << footForces[7] << " " << footForces[8] << " ";
  std::cout << footForces[9] << " " << footForces[10] << " " << footForces[11] << std::endl;
 
  WriteAsDatFile(result, ptr);
  ptr += 1; 
  time = time + 0.002;
  }
  // std::cout << (*result).row(999) << std::endl;

  // (*result).resize(1, (*result).size());
 
  // Eigen::VectorXd d(Eigen::Map<Eigen::VectorXd>((*result).data(),(*result).cols()*(*result).rows()));
  // FILE* f = fopen("/home/chris/Desktop/latest/Cheetah-Software/config/locomotion.dat","w");
  // fwrite(d.data(), sizeof(float), d.size(), f);
  // fclose(f);

  std::ofstream file_out("/home/chris/Desktop/latest/Cheetah-Software/config/Tryout.txt", std::ifstream::binary);
  if (!file_out.is_open()) {
       std::cout << "Error opening file"<< std::endl;
       exit (1);
  }

  for (int row = 0; row < (*result).rows(); row++) {
    for (int col = 0; col < (*result).cols(); col++) {
      file_out << (*result)(row, col) << " "; 
    }
    std::cout << std::endl;
  }
  file_out.close();
}


Eigen::VectorXd
convertJson2Arr(Eigen::Vector4d arr, Json::Value &j) 
{
  for (int i = 0; i < arr.size(); ++i) {
    arr[i] = j[i].asDouble();
  }
  return arr;
}

SVec<double>
convertJson2SVec(SVec<double> arr, Json::Value &j1, Json::Value &j2) 
{
  for (int i = 0; i < 3; ++i) {
    arr[i] = j1[i].asFloat();
  }
   for (int i = 3; i < 6; ++i) {
    arr[i] = j2[i].asFloat();
  }
  return arr;
}

Vec3<double>
convertJson2Vec(Vec3<double> arr, Json::Value &j) 
{
  for (int i = 0; i < arr.size(); ++i) {
    arr[i] = j[i].asFloat();
  }
  return arr; 
}

Eigen::Matrix3d
convertJson2Mat(Eigen::Matrix3d mat, Json::Value &js) 
{
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      mat(i,j) = js[i * 3 + j].asFloat();
    }
  }
  return mat; 
}

Eigen::VectorXd 
convertJson2Xd(Eigen::VectorXd jointPos, Json::Value &js)
{
  for (int i = 0; i < jointPos.size(); i++) {
    jointPos[i] = js[i].asFloat();
  }
  return jointPos;
}

Eigen::VectorXd
DataProcessor::ComputeJointVelocities(float t) {
  
    Eigen::VectorXd v;
    v.resize(12);
    Eigen::Vector3d vec0 = cheetahModel.getLinearVelocity(0);
    Eigen::Vector3d vec1 = cheetahModel.getLinearVelocity(1);
    Eigen::Vector3d vec2 = cheetahModel.getLinearVelocity(2);
    Eigen::Vector3d vec3 = cheetahModel.getLinearVelocity(3);
    for (int i = 0; i < 3; i++) {
      v(i) = vec0(i);
      v(i + 3)  = vec1(i);
      v(i + 6)  = vec2(i);
      v(i + 9)  = vec3(i);
    }
    
    return v; 
}

// Vec12<double>
// DataProcessor::ComputeJointTorques(float t) {
//     // Construct state derivative
//     SVec<double> vbd = convertJson2SVec(vbd, opt["data"][to_string(t)]["Base linear acceleration"], opt["data"][to_string(t)]["Base angular acceleration"]);
//     // DVec<double> qdd(12);
//     // Fill in joint acceleration values 
//     // _model.forwardAccelerationKinematics();
//     // Mat3<double> R = _model.getOrientation(0);
//     // Vec3<double> a = R * spatialToLinearAcceleration(_model._a[0], _model._v[0], Vec3<double>::Zero());
//     DVec<double> qdd(12);
//     qdd << -0.7924, -0.2205, -0.9163, -1.6136, -0.4328, -1.6911, -2.9878, -0.9358,
//         -2.6194, -3.3773, -1.3235, -3.1598;
//     qdd *= 1000;

//     FBModelStateDerivative<double> dx;
//     dx.dBodyVelocity = vbd;
//     dx.qdd = qdd;
//     // Run RNEA inverse dynamics
//     Vec18<double> generalizedForce = cheetahModel.inverseDynamics(dx); // [base_force ; joint_torques]
//     fReturn = generalizedForce.head(6);
//     jointTorques = generalizedForce.tail(12); // prune away base force
//     return jointTorques;
// }

void 
DataProcessor::WriteAsDatFile(Eigen::MatrixXd* result, int i) {

    (*result)(i, 0) = x.bodyPosition[0];
    (*result)(i, 1) = x.bodyPosition[1];
    (*result)(i, 2) =  x.bodyPosition[2];
    (*result)(i, 3) = x.bodyOrientation[0];
    (*result)(i, 4) = x.bodyOrientation[1];
    (*result)(i, 5) = x.bodyOrientation[2];
    (*result)(i, 6) =  (x.q)[0];
    (*result)(i, 7) = (x.q)[1];
    (*result)(i, 8) = (x.q)[2];
    (*result)(i, 9) = (x.q)[3];
    (*result)(i, 10) = (x.q)[4];
    (*result)(i, 11) = (x.q)[5];
    (*result)(i, 12) =(x.q)[6];
    (*result)(i, 13) = (x.q)[7];
    (*result)(i, 14) =  (x.q)[8];
    (*result)(i, 15) = (x.q)[9];
    (*result)(i, 16) = (x.q)[10];
    (*result)(i, 17) = (x.q)[11];
    (*result)(i, 18)= x.bodyVelocity[0];
    (*result)(i, 19) = x.bodyVelocity[1];
    (*result)(i, 20) = x.bodyVelocity[2];
    (*result)(i, 21) = x.bodyVelocity[3];
    (*result)(i, 22) = x.bodyVelocity[4];
    (*result)(i, 23) = x.bodyVelocity[5];
    (*result)(i, 24) =(x.qd)[0];
    (*result)(i, 25) = (x.qd)[1]; 
    (*result)(i, 26) = (x.qd)[2];
    (*result)(i, 27) = (x.qd)[3];
    (*result)(i, 28) = (x.qd)[4];
    (*result)(i, 29) =(x.qd)[5];
    (*result)(i, 30) = (x.qd)[6];
    (*result)(i, 31) = (x.qd)[7];
    (*result)(i, 32) = (x.qd)[8];
    (*result)(i, 33) = (x.qd)[9];
    (*result)(i, 34) = (x.qd)[10] ;
    (*result)(i, 35) = (x.qd)[11];
    (*result)(i, 36) =jointTorques[0] ;
    (*result)(i, 37) = jointTorques[1] ;
    (*result)(i, 38) = jointTorques[2];
    (*result)(i, 39) = jointTorques[3] ;
    (*result)(i, 40) = jointTorques[4] ;
    (*result)(i, 41) =jointTorques[5];
    (*result)(i, 42) = jointTorques[6]; 
    (*result)(i, 43) = jointTorques[7];
    (*result)(i, 44) =jointTorques[8];
    (*result)(i, 45) = jointTorques[9];
    (*result)(i, 46) =jointTorques[10];
    (*result)(i, 47) =jointTorques[11];
    (*result)(i, 48) =footForces[0]; 
    (*result)(i, 49) =footForces[1];
    (*result)(i, 50) =footForces[2];
    (*result)(i, 51) = footForces[3] ;
    (*result)(i, 52) =footForces[4] ;
    (*result)(i, 53) =footForces[5] ;
    (*result)(i, 54) =footForces[6];
    (*result)(i, 55) = footForces[7]; 
    (*result)(i, 56) =footForces[8];
    (*result)(i, 57) =footForces[9];
    (*result)(i, 58) =footForces[10] ;
    (*result)(i, 59) =footForces[11] ;


//   // file_out << (float)x.bodyPosition[0] << " " << (float)x.bodyPosition[1] << " " << (float)x.bodyPosition[2] <<  " " << (float)x.bodyOrientation[0] << " " << x.bodyOrientation[1] << " " << x.bodyOrientation[2] <<  " ";
//   // file_out << (x.q)[0] << " " << (x.q)[1] << " " << (x.q)[2] << " " << (x.q)[3] << " " << (x.q)[4] << " " << (x.q)[5] << " " << (x.q)[6] <<  " " << (x.q)[7] <<  " " << (x.q)[8] <<  " " << (x.q)[9] << " " << (x.q)[10] << " " << (x.q)[11] << " ";
//   // file_out << x.bodyVelocity[0] <<  " " << x.bodyVelocity[1] << " " << x.bodyVelocity[2] <<  " " << x.bodyOrientation[0] << " " << x.bodyOrientation[1] << " " << x.bodyOrientation[2] << " ";
//   // file_out << (x.qd)[0] << " " << (x.qd)[1] << " " << (x.qd)[2] << " " << (x.qd)[3] << " " << (x.qd)[4] << " " << (x.qd)[5] << " " << (x.qd)[6] << " " << (x.qd)[7] << " " << (x.qd)[8] << " " << (x.qd)[9] << " " << (x.qd)[10] << " " << (x.qd)[11] << " ";
//   // file_out << jointTorques[0] << " " << jointTorques[1] << " " << jointTorques[2] << " " << jointTorques[3] << " " << jointTorques[4] << " " << jointTorques[5] << " " << jointTorques[6] << " " << jointTorques[7] << " ";
//   // file_out << jointTorques[8] << " " << jointTorques[9] << " " << jointTorques[10] << " " << jointTorques[11] << " ";
//   // file_out << footForces[0] << " " << footForces[1] << " " << footForces[2] << " " << footForces[3] << " " << footForces[4] << " " << footForces[5] << " " << footForces[6] << " " << footForces[7] << " " << footForces[8] << " ";
//   // file_out << footForces[9] << " " << footForces[10] << " " << footForces[11];
//   // file_out.close();
}

template <typename Iterable> 
Json::Value iterable2json(Iterable const& cont) {
  Json::Value v;
  // for (auto&& element: cont) {
  //   v.append(element);
  // }
  for (auto iteration = 0; iteration < cont.size(); iteration++) {
    v.append(cont[iteration]);
  }
  return v; 
}

